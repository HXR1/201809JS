<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>珠峰培训</title>
</head>
<body>

<div id="app">珠峰培训</div>
<h1>珠峰培训</h1>
</body>
</html>
<script>
    /*
    * 基本数据类型 number string Boolean null undefined
    * 引用数据类型 [] {} reg Data Math fn ...
    * */
    let ary = [1,2,3,4,5];
    ary.pop(); // 删除最后一项 返回值是删除的那一项  改变原有数组
    ary.push('rrr',123,[123],{});// 向数组末尾添加项 返回值是改变后的数组的长度  改变原有数组
    ary.length--;

    ary.shift();// 删除首项  返回值是删除的首项  改变原有数组
    ary.unshift('qwqq',12,[]); // 向数组的头部添加 返回值是改变后的数组的长度  改变原有数组

    ary.sort((a,b)=>{return a - b});// 升序排列数组  返回值是排序后的数组 改变原有数组 ; ----> 返回值和原数组 是一个地址；
    // ary.sort((a,b)=>a - b);

    let ary2 = [{id:1},{id:3},{id:21},{id:0},{id:444}];
    ary2.sort((a,b)=>{return a.id - b.id}); // 把数组 以每一项的 id 排序

    ary.reverse();// 倒序  返回值 倒序后的数组； 返回值和园有数组是一个地址；

    //ary.splice(m,n,x,y,z)// 从索引m开始，删除n个，用后边这些参数替换删除的项
    ary.splice(3,0,12,13,14);// 在索引3 的前边添加 3项

//    以上方法都是改变原有数组的  我们把这些方法改编后的数组 称为数组的变异

    // 不改变原有数组的方法  concat slice join toString indexOf ...

    /*
    * 数组的迭代
    * */
    let arr = [1,2,3,4,5];
    arr.__proto__.aaa = 222;
    arr.qqq = 123;
    for(let i = 0 ; i < arr.length ; i++){
        console.log(arr[i])
    }
    // for in   循环对象 、
    for(let k in arr){
        console.log(arr[k])
    }
    // for of 循环数组
    for(let val of arr){
        console.log(val) // value 是数组中的值
    }

    let res = arr.forEach(function (item,index) {
        //item 数组中的当前项
        //index 当前项对应的索引
        console.log(arguments)
    });
    // res 是undefined

    let res2 = arr.map(function (item,index) {
        if(index > 2){
            return 1
        }else {
            return 2
        }
    });
    // map的返回结果是个新数组；数组中的每一项 是由回调函数的return值决定的；

    arr = [1,2,3,4,5];
    let res3 = arr.some((item,index)=>{
        console.log('q');
        return index > 2
    });
    // 返回值是个 布尔类型
    // 返回值若是 true : 所有的回调函数中，至少有一个 return 的值是 true
    // 返回值若是 false: 所有的回调函数返回值都是 false
    // 迭代次数  当碰到return true时，后边的项不再迭代；


    let res4 = arr.every((item,index)=>{

    });
    // 语法同上； 用法跟some 正好相反；
    // 只要有一个回调的返回值时false 那么结果就是false
    // 全是true时返回结果才是true；
    // 迭代次数  当碰到 return false 时，迭代结束

    let res5 = arr.filter((item,index)=>{
        return true ;
    });
    // 过滤数组用的； 返回值是个新数组； 数组中的项决定于 回调函数的return的布尔值
    // 若 当前迭代 让return true ;则把当前项放到新数组中；

    let res6 = arr.reduce((prev,next)=>{
        console.log(prev,next);
        // 本次的prev 就是 上一次的回调的  return值
        // reduce 有两个参数 ；第一个参数是个回调函数 ；第二个参数可以不写；若写了，则是回调函数的第一个 prev 值；不写的话，回调函数的第一个 prev 是数组中的第一项
        // reduce的返回值是 最后一次回调的 return值
        return next
    })

    //使用reduce 进行数组求和
    let res7 = arr.reduce((prev,next)=>{
        return prev + next
    })
    // 1 + 2
    // 3 + 3
    // 6 + 4





</script>